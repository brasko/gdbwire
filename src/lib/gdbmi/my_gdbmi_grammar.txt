GDB/MI Output Syntax

Description of GDB/MI from GDB documentation
--------------------------------------------

output              -> (out-of-band-record)* [result-record] "(gdb)" nl
result-record       -> [token] "^" result-class ("," result)* nl
out-of-band-record  -> async-record | stream-record
async-record        -> exec-async-output | status-async-output |
                       notify-async-output 
exec-async-output   -> [token] "*" async-output 
status-async-output -> [token] "+" async-output 
notify-async-output -> [token] "=" async-output 

async-output        -> async-class ("," result)* nl
result-class        -> "done" | "running" | "connected" | "error" | "exit"
async-class         -> "stopped"
result              -> variable "=" value
variable            -> string
value               -> const | tuple | list
const               -> c-string
tuple               -> "{}" | "{" result ("," result)* "}"
list                -> "[]" | "[" value ("," value)* "]" |
                       "[" result ("," result)* "]"

stream-record       -> console-stream-output |
                       target-stream-output |
                       log-stream-output

console-stream-output   -> "~" c-string
target-stream-output    -> "@" c-string
log-stream-output       -> "&" c-string
nl                      -> CR | CR-LF
token                   -> any sequence of digits. 

The documented syntax described in the GDB manual can not be
directly plugged into bison as a LR(1) grammar. For this reason I take
some steps to document how I've changed the syntax above to be suitable
for LR(1) parsing with bison.

Transformations
---------------

I've come across two patterns that bison likes as input for LR(1) grammars.

Zero or more rules like the regular expression (pattern)* look like this:
  pattern_list -> epsilon
  pattern_list -> pattern_list pattern

One or more rules like the regular expression (pattern)+ look like this:
  pattern_list -> pattern
  pattern_list -> pattern_list pattern

Zero or one rules like the regular expression [pattern] look like this:
  opt_pattern -> epsilon
  opt_pattern -> pattern

Below are the transformations that I use to get from the documented
sytax above to the LR(1) grammar I provide to bison.

- (out-of-band-record)* transforms to out-of-band-record-list
  out-of-band-record-list -> epsilon
  out-of-band-record-list -> out-of-band-record-list out-of-band-record

- [result-record] transforms to opt-result-record
  opt-result-record -> epsilon
  opt-result-record -> result-record

- [token] transforms to opt-token
  opt-token -> epsilon
  opt-token -> token

- ("," result)* transforms to result-list
  result-list -> epsilon
  result-list -> result-list "," result

- ("," value)* transforms to value-list
  value-list -> epsilon
  value-list -> value-list "," value

- Consolidate the following rules to a more consice set of rules
- From
    async-record        -> exec-async-output |
                           status-async-output |
                           notify-async-output 
    exec-async-output   -> [token] "*" async-output 
    status-async-output -> [token] "+" async-output 
    notify-async-output -> [token] "=" async-output 

 To
    async-record        -> opt-token async-output-choice async-output
    async-output-choice -> "*" | "+" | "="

- Consolidate the following rules to a more consice set of rules
- From
    stream-record       -> console-stream-output |
                           target-stream-output |
                           log-stream-output

    console-stream-output   -> "~" c-string
    target-stream-output    -> "@" c-string
    log-stream-output       -> "&" c-string

  To 
    stream-record       -> stream-record-choice c-string
    stream-record-choice-> "~" | "@" | "&"

Finally, gdbwire must be able to receive many output commands during
a single session. So the grammar supports accepting an output list.

Please note that the oob-record-list rule,
  oob-record-list -> oob-record-list oob-record nl
and the opt-result-record rule,
  opt-result-record   -> result-record nl
have a newline at the end of them even though it is not in the GDB syntax.

On the contrary, the syntax has,
    async-output        -> async-class ("," result)* nl
but there is no nl after the async output.

These are most likely errors in the GDB syntax.

LR(1) Grammar
-------------

output-list         -> output-list output | output
output              -> oob-record-list opt-result-record "(gdb)" nl
oob-record-list     -> oob-record-list oob-record nl | epsilon
opt-result-record   -> result-record nl | epsilon
result-record       -> opt-token "^" result-class result-list
oob-record          -> async-record | stream-record
async-record        -> opt-token async-record-choice async-output
async-record-choice -> "*" | "+" | "="
async-output        -> async-class result-list
result-class        -> "done" | "running" | "connected" | "error" | "exit"
async-class         -> "stopped"
result-list         -> result-list "," result | epsilon
result              -> variable "=" value
variable            -> string
value-list          -> value-list "," value | epsilon
value               -> c-string | tuple | list
tuple               -> "{}" | "{" result result-list "}"
list                -> "[]" |
                       "[" value value-list "]" | "[" result result-list "]"
stream-record       -> stream-record-choice c-string
stream-record-choice-> "~" | "@" | "&"
nl                  -> CR | CR LF
opt_token           -> token | epsilon
token               -> [0-9]+
