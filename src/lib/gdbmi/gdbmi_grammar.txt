GDB/MI Output Syntax

Description of GDB/MI from GDB documentation
--------------------------------------------

output              -> (out-of-band-record)* [result-record] "(gdb)" nl
result-record       -> [token] "^" result-class ("," result)* nl
out-of-band-record  -> async-record | stream-record
async-record        -> exec-async-output | status-async-output |
                       notify-async-output 
exec-async-output   -> [token] "*" async-output 
status-async-output -> [token] "+" async-output 
notify-async-output -> [token] "=" async-output 

async-output        -> async-class ("," result)* nl
result-class        -> "done" | "running" | "connected" | "error" | "exit"
async-class         -> "stopped" | "running" | "download"
result              -> variable "=" value
variable            -> string
value               -> const | tuple | list
const               -> c-string
tuple               -> "{}" | "{" result ("," result)* "}"
list                -> "[]" | "[" value ("," value)* "]" |
                       "[" result ("," result)* "]"

stream-record       -> console-stream-output |
                       target-stream-output |
                       log-stream-output

console-stream-output   -> "~" c-string
target-stream-output    -> "@" c-string
log-stream-output       -> "&" c-string
nl                      -> CR | CR-LF
token                   -> any sequence of digits. 

The documented syntax described in the GDB manual can not be
directly plugged into bison as a LR(1) grammar. For this reason I take
some steps to document how I've changed the syntax above to be suitable
for LR(1) parsing with bison.

Transformations
---------------

I've come across two patterns that bison likes as input for LR(1) grammars.

Zero or more rules like the regular expression (pattern)* look like this:
  pattern_list -> epsilon
  pattern_list -> pattern_list pattern

One or more rules like the regular expression (pattern)+ look like this:
  pattern_list -> pattern
  pattern_list -> pattern_list pattern

Zero or one rules like the regular expression [pattern] look like this:
  opt_pattern -> epsilon
  opt_pattern -> pattern

Below are the transformations that I use to get from the documented
sytax above to the LR(1) grammar I provide to bison.

- (out-of-band-record)* transforms to out-of-band-record-list
  out-of-band-record-list -> epsilon
  out-of-band-record-list -> out-of-band-record-list out-of-band-record

- [result-record] transforms to opt-result-record
  opt-result-record -> epsilon
  opt-result-record -> result-record

- [token] transforms to opt-token
  opt-token -> epsilon
  opt-token -> token

- ("," result)* transforms to result-list
  result-list -> epsilon
  result-list -> result-list "," result

- ("," value)* transforms to value-list
  value-list -> epsilon
  value-list -> value-list "," value

- Consolidate the following rules to a more consice set of rules
- From
    async-record        -> exec-async-output |
                           status-async-output |
                           notify-async-output 
    exec-async-output   -> [token] "*" async-output 
    status-async-output -> [token] "+" async-output 
    notify-async-output -> [token] "=" async-output 

 To
    async-record        -> opt-token async-output-kind async-output
    async-output-kind   -> "*" | "+" | "="

- Consolidate the following rules to a more consice set of rules
- From
    stream-record       -> console-stream-output |
                           target-stream-output |
                           log-stream-output

    console-stream-output   -> "~" c-string
    target-stream-output    -> "@" c-string
    log-stream-output       -> "&" c-string

  To 
    stream-record       -> stream-record-kind c-string
    stream-record-kind  -> "~" | "@" | "&"

Simplifications
---------------

Below are some simplifications I've made to the grammar.

1) async-output

  async-output is used in one location and defined in one location. It makes
  sense to combine this rule with the rule that uses it, async-record.

  To accomplish this, change the grammar
  From:
    async-record        -> opt-token async-record-kind async-output
    async-output        -> async-class result-list
  To
    async-record        -> opt-token async-record-kind async-class result-list

Extensions to GDB/MI
--------------------

Finally, gdbwire must be able to receive many output commands during
a single session. So the grammar supports accepting an output list.

GDB/MI Bug Fixes
----------------

1) The GDB/MI newline bug

  It appears that the GDB/MI specification incorrectly states in the grammar
  where the newlines are placed. This documentation shows how I've changed the
  GDB/MI grammar to handle the actual newlines put out by GDB/MI.

  Please note that the oob-record-list rule,
    oob-record-list -> oob-record-list oob-record nl
  and the opt-result-record rule,
    opt-result-record   -> result-record nl
  have a newline at the end of them even though it is not in the GDB syntax.

  On the contrary, the syntax has,
      async-output        -> async-class ("," result)* nl
  but there is no nl after the async output.

2) The GDB/MI result versus value bug

  You can think of a result as a key/value pair. Where the key component is
  a string name, and the value component is a c-string, tuple or list.

  The GDB/MI specification attempts to clearly state where value's will be
  used and where result's will be used. The reality is, it does this wrong.
  There are places where it specifies a result will be, but a value is found.
  A case I found like this is with async-output records which contain values
  instead of results like specified.
    -target-download
    ...
    +download,{section=".interp",section-size="28",total-size="2466"}
              ^ This should start a result, not a value.

  The solution to this problem is to relax the parser. To do this, I drop
  the value concept. The result now represents the c-string, tuple or list
  and it contains an optional key.

  This fix resolves the buggy GDB/MI result/value specification at the
  parser level and pushes the problem to the semantic layer. That is,
  certain front ends may expect or not expect the key to be set at certain
  locations in the parser tree.

  To implement the above modifications to the GDB/MI parser specification,
  the following changes are made to the grammar.

  The value-list and value rule are removed. Removing these,
    value-list          -> value-list "," value | epsilon
    value               -> c-string | tuple | list

  The value-list rule was only used in the list rule. The list rule is
  changed to use result-list instead.
  From
    list                -> "[]" |
                       "[" value value-list "]" | "[" result result-list "]"
  To
    list                -> "[]" | "[" result result-list "]"

  The value rule was only used in the result rule. So result was changed
  From
    result              -> variable "=" value
    value               -> c-string | tuple | list
  To
    opt_variable        -> variable "=" | epsilon
    result              -> opt_variable c-string
    result              -> opt_variable tuple
    result              -> opt_variable list
  
LR(1) Grammar
-------------

output-list         -> output-list output | epsilon
output              -> oob-record-list opt-result-record "(gdb)" nl
oob-record-list     -> oob-record-list oob-record nl | epsilon
opt-result-record   -> result-record nl | epsilon
result-record       -> opt-token "^" result-class result-list
oob-record          -> async-record | stream-record
async-record        -> opt-token async-record-kind async-class result-list
async-record-kind   -> "*" | "+" | "="
result-class        -> "done" | "running" | "connected" | "error" | "exit"
async-class         -> "stopped" | "running" | "download"
opt_variable        -> variable "=" | epsilon
result-list         -> result-list "," result | epsilon
result              -> opt_variable c-string
result              -> opt_variable tuple
result              -> opt_variable list
variable            -> string
tuple               -> "{}" | "{" result result-list "}"
list                -> "[]" | "[" result result-list "]"
stream-record       -> stream-record-kind c-string
stream-record-kind  -> "~" | "@" | "&"
nl                  -> CR | CR LF
opt_token           -> token | epsilon
token               -> [0-9]+
